#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=debug,topic=MUnit)
##  Testing the assert support.
def_slotted_exemplar(:assert_test,
{},
{:test_case})
$

_pragma(classify_level=debug,topic=MUnit)
assert_test.define_shared_constant(:test_aspects, property_list.new_with(:always, "Always"), :public )
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_nan_fails()

#	 _self.assert_raised_condition( :assertion_failed_warning ,
#					_self , :assert_equals|()|,
#					{ 1.234, 0.0/0.0, _unset , 1.1 })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_nan_equals_fails()

#	_self.assert_raised_condition( :assertion_failed_warning ,
#				       _self , :assert_equals|()|,
#				       { 0.0/0.0, 1.234, _unset  , 1.1 })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_nan_equals_NaN_fails()

#	_self.assert_raised_condition( :assertion_failed_warning ,
#				       _self , :assert_equals|()|,
#				       { 0.0/0.0 , 0.0/0.0 , _unset , 1.1 } )
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_pos_infinity_not_equals_neg_infinity()

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert_equals|()|,
				       { float.infinity , float.minus_infinity , _unset , 4654 })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_pos_infinity_not_equals()

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert_equals|()|,
				       { float.infinity , 1.23 , _unset , 45678 })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_pos_infinity_equals_infinity()

	_self.assert_equals( float.infinity , float.infinity , _unset , 23.5 )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_neg_infinity_equals_infinity()

	_self.assert_equals( float.minus_infinity , float.minus_infinity , _unset , 77.4 )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals()

	_self.assert_equals( assert_test , assert_test , "same object instance" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_differently()

	_self.assert( assert_test , :|=| ,  assert_test , "same object instance" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_not_equals()

	_self.assert( "2" , :|~=| , "3" , "not same numbers" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_unset()

	_self.assert_equals( _unset , _unset , "unset equal test" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_unset_not_equals_not_unset()

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert_equals|()|,
				       { _unset , assert_test })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_identity()

	_self.assert( object, :is  , object , "object exemplar identity" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_not_identity()

	_self.assert( "abc" , :isnt , "abc" , "string isnt string" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_identity_fails()

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert|()|,
				       { "abc" , :is , "abc" , "string is string" }) 
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_fail()

	a_message << "test fail() method"
	
	flag? << _false 
	
	_try _self.fail()
	_when assertion_failed_warning
	      flag? << _true 
	_endtry 

	_if _not flag?
	_then 
		condition.raise( :assertion_failed_warning , a_message ) # can't call fail here
	_endif

	_self.assert( flag? , :|=| , _true , a_message )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_error()

	_self.assert_raised_condition( :does_not_understand , 25 , :abcd , {} , "25.abcd fails" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_fail_assert_not_unset()
	
	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert|()| , 
				       { _unset , :isnt , _unset } )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_succeed_access_not_unset()
	
	_self.assert( object , :isnt , _unset )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_false()
	
	_self.assert( _false , :is , _false )
	
	_self.assert_raised_condition( :assertion_failed_warning ,
				      _self , :assert|()| ,
				      { _true , :is , _false } )
	
	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert|()| ,
				       { 25 , :is , _false } )
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_less()
	
	_self.assert( 12  , :|<| , 23 , "compare numbers" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_less_fails()
	
	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert|()| ,
				       { 12  , :|<| , 12 , "compare numbers" } )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_greater()
	
	_self.assert( %c , :|>| , %a , "compare chars" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_greater_fails()
	
	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert|()| ,
				       { "cb"  , :|>| , "cc" , "compare strings" } )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_greater_or_equals()
	
	_self.assert( %c , :|>=| , %c , "compare chars" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_less_or_equals_fails()

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert|()| ,
				       { 35  , :|<=| , 34 , "compare numbers" })
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_same_kind()

	_self.assert( 23 , :is_kind_of?|()| , simple_number_mixin , "23 is number?" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_same_class()

	_self.assert( 23 , :is_class_of?|()| , integer , "23 is integer?" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_inherits_from()

	_self.assert( 23 , :inherits_from?|()| , number_mixin )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_responds_to()

	_self.assert( 23.34 , :responds_to?|()| , :abs , "responds to message" )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_includes()

	_self.assert( { 2 , 3 , 5 } , :includes?|()| , 2 ,"{2,3,5} incl?. 2")
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_abs_delta()
	## 
	
	_self.assert_equals( 1 , 2 , _unset , 2 )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_rel_delta()
	## 

	_self.assert_equals( 3 , 2.8 , _unset , 0.3 , _true )
	_self.assert_equals( 3 , 3.8 , _unset , 0.3 , _true )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_abs_delta_fails()
	## 

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert_equals|()|,
				       { 1 , 3 , _unset , 1 } )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_equals_rel_delta_fails()
	## 

	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert_equals|()|,
				       { 3 , 2 , _unset , 0.3 , _true })
	
	_self.assert_raised_condition( :assertion_failed_warning ,
				       _self , :assert_equals|()|,
				       { 3 , 4 , _unset , 0.3 , _true })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_empty_simple_vector()

	_self.assert_deep_equals( {}, {} )		
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_new_empty_simple_vector()

	_self.assert_deep_equals( simple_vector.new(2),  simple_vector.new(2) )
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_one_element_simple_vector()

	_self.assert_deep_equals( {1}, {1} )		
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_different_sized_simple_vector()
	

	_self.assert_raised_condition( :assertion_failed_warning ,
				      _self , :assert_deep_equals|()| ,
				      { {1} , {1,2} })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_different_content_simple_vector()
	

	_self.assert_raised_condition( :assertion_failed_warning ,
				      _self , :assert_deep_equals|()| ,
				      { {1} , {2} })
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_longer_simple_vector()
	

	_self.assert_raised_condition( :assertion_failed_warning ,
				      _self , :assert_deep_equals|()| ,
				      { {1,2,3} , {1,2,4} })
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_varied_contents_simple_vector()

	_self.assert_deep_equals( {1,3,:test,_maybe,"abcd",_true,_false,0.5,coordinate.new(1,1), {}, 123456789123456},
				  {1,3,:test,_maybe,"abcd",_true,_false,0.5,coordinate.new(1,1), {}, 123456789123456} )
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_non_matching_vector_of_vectors()
	_self.assert_raised_condition( :assertion_failed_warning ,
				      _self , :assert_deep_equals|()| ,
				      { {{1,2,3}} , {{2}} })

	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_matching_vector_of_vectors()

	_self.assert_deep_equals( { {1,2,3} }, { {1,2,3} } )
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_matching_deep_vectors()

	_self.assert_deep_equals( {
					  {_maybe, :test,
					     {1,2,_false,
					        {"abcd",3.4,coordinate.new(1,2)}
					     }
					  }
					  
				  },
				  {
					   {_maybe, :test,
					     {1,2,_false,
					        {"abcd",3.4,coordinate.new(1,2)}
					     }
					  }
					  
				  } )
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_different_sized_simple_vector()
	

	_self.assert_equals("sizes are not equal at key /",
			    _self.sys!perform(:|compare_indexed_collection()|, {1} , {1,2} ))
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_message_different_sized_simple_vector()
	
	_local me << _self
	_block 
		_handling assertion_failed_warning _with
		_proc(cond)
			_import me
			me.assert_equals("sizes are not equal at key /", cond[:message])
		_endproc
		
	
		_self.assert_deep_equals( {1} , {1,2} )
	_endblock 
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_different_contents_simple_vector()
	

	_self.assert_equals("2 <> 3 at key /2",
			    _self.sys!perform(:|compare_indexed_collection()|, {1,2} , {1,3} ))
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_different_sized_first_level_simple_vector()
	

	_self.assert_equals("sizes are not equal at key /2",
			    _self.sys!perform(:|compare_indexed_collection()|, {1,{:a,:b}} , {1,{:a}} ))
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_different_sized_recursive_simple_vector()
	

	_self.assert_equals("sizes are not equal at key /2/3",
			    _self.sys!perform(:|compare_indexed_collection()|,
					      {1,{:a,"test",{"a","b"}}},
					      {1,{:a,"test",{"a","b",10}}}   ))
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_different_contents_recursive_simple_vector()
	

	_self.assert_equals("True <> Maybe at key /2/1/2",
			    _self.sys!perform(:|compare_indexed_collection()|,
					      { 1,
					        { {:a,_true},
						  "test",
						  {"a","b",10}
						}
					      },
					      { 1,
					        { {:a,_maybe},
						  "test",
						  {"a","b",10}
						}
					      }   ))
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_empty_rope()
	expected << rope.new()
	actual << rope.new()
	_self.assert_deep_equals(expected, actual)		
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_one_element_rope()
	expected << rope.new_with(10)
	actual <<  rope.new_with(10)
	_self.assert_deep_equals(expected, actual)		
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_recursive_same_content_rope()

	rope1 << rope.new_with(:test, "blah")
	rope2 << rope.new_with(:test, "blah")
	expected << rope.new_with(10,20,:test,{0.43,coordinate.new(10,20)},rope1)
	actual << rope.new_with(10,20,:test,{0.43,coordinate.new(10,20)},rope2)	

	_self.assert_deep_equals(expected, actual)		
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_recursive_different_content_rope()

	rope1 << rope.new_with(:test, "blah")
	rope2 << rope.new_with(:test, "blh")
	
	expected << rope.new_with(10,
			   20,
			   rope1,
			   :test,
			   {
				   0.43,
				   coordinate.new(10,20),
				   {_true,"test"},
				   5
			   }
			   )
			  
	actual << rope.new_with(10,
			  20,
			  rope2,
			  :test,
			  {
				  0.43,
				  coordinate.new(10,20),
				  {_true,"test"},
				  5
			  }
			 )	

	_self.assert_equals("blah <> blh at key /3/2",
			    _self.sys!perform(:|compare_indexed_collection()|,
					      expected,
					      actual)
			    )
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_is_same_class?_rope_and_simple_vector()
	expected << rope.new_with(1,2)
	actual << {1,2}
	_self.assert_deep_equals("Expected a rope ,but is a simple_vector",
			    _self.sys!perform(:|is_same_class?()|,
					      expected,
					      actual)
			    )

_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_empty_property_list()
	expected << property_list.new()
	actual << property_list.new()
	_self.assert_deep_equals( expected, actual)
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_assert_deep_equals_single_element_property_list()
	expected << property_list.new_with(:one,1)
	actual << property_list.new_with(:one,1)
	_self.assert_deep_equals(expected,actual)	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method assert_test.test_compare_different_key_property_list()
	expected << property_list.new_with(:one,1)
	actual << property_list.new_with("two",1)
	_self.assert_equals("The key 'one' is unique at key /",
			    _self.sys!perform(:|compare_external_keyed_collection()|,
					      expected,
					      actual)
	      )
_endmethod
$

