#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=basic,topic=MUnit)
##
def_slotted_exemplar(:base_test_runner,
{
	{ :test_result , _unset , :readable  },
	{ :properties  , property_list.new_with( :exclude_slow_tests? , _false  ,
						 :max_tests       , float.infinity ,
						 :max_failures    , float.infinity ,
						 :max_errors      , float.infinity ,
						 :max_assertions  , float.infinity 
				       ),
	  :readable
	} 
},
{ :engine_model , :test_listener_interface })
$

_pragma(classify_level=advanced,topic=MUnit)
_method base_test_runner.init_properties( _gather keys_and_elements )
	## Init properties of runner from KEYS_AND_ELEMENTS.
	
	.properties << property_list.new_from_gathered( keys_and_elements )
	
	.properties[:exclude_slow_tests?] << .properties[:exclude_slow_tests?].default( _false )
	.properties[:max_tests ]     << .properties[:max_tests].default( float.infinity )
	.properties[:max_failures]   << .properties[:max_failures].default( float.infinity )
	.properties[:max_errors]     << .properties[:max_errors].default( float.infinity )
	.properties[:max_assertions] << .properties[:max_assertions].default( float.infinity )
_endmethod
$

_pragma(classify_level=advanced,topic=MUnit)
_method base_test_runner.run_bare( a_test )
	## 

	exclude_slow_tests? << .properties[:exclude_slow_tests?]
	
	.test_result << mtest_result.new( exclude_slow_tests? )
	.test_result.add_listener( _self )

	start_time << system.elapsed_seconds()
	a_test.run( .test_result )
	end_time << system.elapsed_seconds()
	run_time << end_time - start_time

	>> run_time
_endmethod
$

_pragma(classify_level=advanced,topic=MUnit)
_method base_test_runner.stop()
	## Preferable way how to stop runnner.
	## This will stop execution of tests
	## after current running test is finished.
	## Another option is heavy gun KILL_TEST_THREAD().
	
	_if .test_result _isnt _unset
	_then
		.test_result.stop()
	_endif 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method base_test_runner.end_test( a_test )
	## Implementation of abstract method from test_listener_interface. 

	max_tests      << .properties[ :max_tests ]
	max_failures   << .properties[:max_failures]
	max_errors     << .properties[:max_errors]
	max_assertions << .properties[:max_assertions]

	_if ( .test_result.run_count()     >= max_tests   ) _orif 
	    ( .test_result.failure_count() >= max_failures) _orif
	    ( .test_result.error_count()   >= max_errors  )  _orif
	    ( .test_result.assert_count()  >= max_assertions  )  
	_then
		.test_result.stop()
	_endif 
_endmethod
$

_pragma(classify_level=advanced,topic=MUnit)
_method base_test_runner.kill_test_thread()
	## Kill main test thread and all children threads created
	## in active test suites.
	
	_if ( result? << _self.interrupt_engine() )
	_then
		_if active_test_suite _isnt _unset
		_then 
			active_test_suite.kill_all_active_tests()
		_endif 
	_endif
	
	>> result?
_endmethod
$
