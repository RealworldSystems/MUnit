#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=advanced,topic=MUnit)
def_slotted_exemplar(:db_test_case,
{
	{ :ds_views , _unset }
},
{:test_case})
$

_pragma(classify_level=restricted,topic=MUnit,usage=subclassable)
_method db_test_case.ds_views
	## Default views for unit testing.

	_global gis_program_manager
	
	_if .ds_views _is _unset 
	_then
		.ds_views << property_list.new()
	_endif

	_if (a_view << gis_program_manager.databases[:gis]) _isnt _unset
	_then 
		.ds_views[:gis] << a_view
	_endif

	>> .ds_views
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit,usage=subclassable)
_method db_test_case.main_testing_alternative_name

	## Return the name of the current user to use as the
	## alternative name
	
	>> system.user_name.as_symbol()
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
db_test_case.define_shared_constant( :checkpoint_name , :after_one_time_setup , :private )
$

_pragma(classify_level=basic,topic=MUnit,usage=subclassable)
_private _method db_test_case.one_time_setup_database()
	## Default do nothing.
	
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method db_test_case.run_bare()
	## Runs the bare test sequence

	_self.setup_db()
	_self.set_up()
	
	_protect
		_self.run_test()
	_protection
		_self.tear_down()
		_self.teardown_db()
	_endprotect
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method db_test_case.setup_db()

	## Set up the database ready for the test, possibly creating it
	## from scratch.

	_if _self.ds_views.empty?
	_then
		_self.create_database()
	_endif 
	
	_self.goto_test_alternatives()
	_self.clear_alternatives_and_checkpoints()

	_if _self.one_time_setup_failed?()
	_then
		_self.align_datasets()
		_self.one_time_setup_database()
		_self.create_test_checkpoints()
	_else 
		_self.goto_test_checkpoints()
	_endif
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method db_test_case.goto_test_alternatives()
	## 

	_for a_ds_view _over _self.ds_views.fast_elements()
	_loop
		a_ds_view.rollback()
		
		_if ( a_path << a_ds_view.alternative_path ).empty? _orif 
		    a_path.last ~= _self.class_name.write_string
		_then
			a_ds_view.goto_top_alternative()
			
			_if _not a_ds_view.has_alternative?( _self.main_testing_alternative_name )
			_then
				a_ds_view.spawn( _self.main_testing_alternative_name )
			_endif
			
			a_ds_view.go_to_alternative( _self.main_testing_alternative_name , :write )
			
			_if _not a_ds_view.has_alternative?( _self.class_name )
			_then
				a_ds_view.spawn( _self.class_name )
			_endif
			
			a_ds_view.go_to_alternative( _self.class_name , :write )
		_endif 
	_endloop 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method db_test_case.one_time_setup_failed?()
	## 

	>> _not _self.ds_views.an_element().has_checkpoint?( _self.checkpoint_name ) 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method db_test_case.align_datasets()

	## Discard any changes in the views and reset them so they are
	## identical to their parent alternatives

	_for a_ds_view _over _self.ds_views.fast_elements()
	_loop
		a_ds_view.switch(:write)
		a_ds_view.rollback()
		a_ds_view.align()
	_endloop 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method db_test_case.create_test_checkpoints()
	## 

	_for a_ds_view _over _self.ds_views.fast_elements()
	_loop
		a_ds_view.checkpoint( _self.checkpoint_name )
	_endloop 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method db_test_case.goto_test_checkpoints()
	## 

	_for a_ds_view _over _self.ds_views.fast_elements()
	_loop
		a_ds_view.go_to_checkpoint( _self.checkpoint_name , :write )
	_endloop 
_endmethod
$

_pragma(classify_level=advanced,topic=MUnit, usage={subclassable})
_method db_test_case.teardown_db()
	
	## Stub method called after a test is run.
	##
	## This does not clear the database because it is useful to
	## leave it in the test state for debugging purposes.  Subclass
	## it if you do want to do something to the database at the end
	## of the test.
	
_endmethod
$

_pragma(classify_level=advanced,topic=MUnit)
_method db_test_case.infrastructure?
	## Return true for children of test case.

	>> _self _is db_test_case
_endmethod
$
_pragma(classify_level=restricted,topic=MUnit)
_private _method db_test_case.clear_alternatives_and_checkpoints()

	## Tear down databasase alternative.

	test_check << _self.checkpoint_name
	
	_for a_ds_view _over _self.ds_views.fast_elements()
	_loop
		_for an_alternative _over a_ds_view.alternatives.fast_elements()
		_loop
			a_ds_view.remove_alternative( an_alternative.alternative_name, _true )
		_endloop
		
		_for a_checkpoint _over a_ds_view.checkpoints.fast_elements()
		_loop
			name << a_checkpoint.checkpoint_name
			_if name <> test_check
			_then 
				a_ds_view.remove_checkpoint(name)
			_endif 
		_endloop
	_endloop
_endmethod
$

