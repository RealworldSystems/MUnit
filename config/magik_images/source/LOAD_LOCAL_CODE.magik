#% text_encoding = iso8859_1
_package sw

#
# This file contains code to customise images for the local environment
# It is loaded by LOAD_SYS_BASE but only if it exists.  It is
# specifically marked as miss so that it is not loaded in the
# shipped product.
#
_block

	write("setting time zone to Europe/London")
	date_time_environ.dst_rules_name << "Europe/London"

_endblock
$

# Following changes cause reporting of loading and check symbol table.
# Added 9-06-2009 to try to find problem with symbol table
# apparently being overwritten
#_private _method magik_rep.report_end_loading_and_check_symbol_table( name )
#	!output!.put_charvec( "Loaded: " + name )
#	!output!.newline()
#	_for k,e _over symbol_table.sys!slot(:keys).fast_keys_and_elements()
#	_loop	       
#		e.as_oop
#	_endloop
#	!output!.put_charvec( "Symbol table OK" )
#	!output!.newline()
#_endmethod
#$
#_pragma(classify_level=advanced, topic={code})
#_method magik_rep.load_compiled_file(name, _optional source_file_name)
#
#	## Loads in a magikc file.
#	##
#	## If source_file_name is specified, the method finder will
#	## be informed that this is the source file. Otherwise, the
#	## method finder will not have a source file reference.
#	
#	_self.write_message(!output!, :loading, name)
#
#	# for the method finder
#	_dynamic !source_file! << _unset
#
#	_local taga << "abort_load".copy()
#	_local tagc << "continue_load".copy()
#
#	_local (abort1, abortn, errors) <<
#		_self.abort_procs(_unset, taga, tagc)
#
#	verbose? << _not _self.load_magikc_quietly?
#	
#	_catch taga
#	       _dynamic !abort!
#
#	       # during file open any error is fatal.
#	       !abort! << abort1
#
#	       _if source_file_name _isnt _unset
#	       _then !source_file!  << system.canonicalise(source_file_name)
#	       _endif
#	
#	       # This will be stored in any procedure compiler_info.
#	       _dynamic !compiler_file! << system.canonicalise(name)
#	       _dynamic !patch_module! << _unset
#
#	       _dynamic (!current_module!, !module_file!) <<
#		       _self.module_and_path(!source_file!.default(!compiler_file!))
#	       
#	       # this may be updated during processing
#	       _dynamic !current_package!
#	       
#	       input << magikc_input_stream.new(name)
#	       _protect
#
#		       # check for package selection
#		       pname << input.compiler_info[:current_package]
#		       _if pname _isnt _unset _andif
#			   pname _isnt !current_package!.name
#		       _then
#			       _if (def_pack << package(pname, _true)) _isnt _unset
#			       _then
#				       !current_package! << def_pack
#			       _else 
#				       condition.raise(:magikc_package_missing,
#						       :old_package, pname,
#						       :magikc_file, name,
#						       :new_package, !current_package!.name)
#			       _endif 
#		       _endif
#
#		       _loop
#			       _catch tagc
#				      _handling load_file_stop
#				      _with _proc(cond)
#						    _import taga
#						    cond.report_contents_on (!output!) 
#						    newline_char.write_on (!output!)
#						    _throw taga 
#				      _endproc 
#						    
#						    
#				      # errors reading the compiled source are also fatal.
#				      !abort! << abort1
#				      chunk << input.get_cg_chunk()
#				      _if chunk _is _unset _then _leave _endif
#				      # during process errors may be recoverable
#				      !abort! << abortn
#				      _for c _over chunk.elements()
#				      _loop
#					      _self.process(input.prepare_for_process(c),verbose?)
#				      _endloop
#			       _endcatch
#		       _endloop
#		
#	       _protection
#		       input.close()
#	       _endprotect
#	_endcatch
#
#	_self.report_end_loading_and_check_symbol_table( name )
#	
#	errors << errors.value	
#	_return errors = 0, errors
#_endmethod
#$
#_private _method magik_rep.do_load_file(name, compiled_output, max_errors,
#					source_file_name)
#
#	## Common code for load_file and compile_file
#
#	
#	_local taga << "abort_load".copy()
#	_local tagc << "continue_load".copy()
#	_local l << _unset
#	
#	_local (abort1, abortn, errors) <<
#		_self.abort_procs(max_errors, taga, tagc)
#	_local stopped? << _false
#	_catch taga
#	       _dynamic !abort! << abort1
#	       s << external_text_input_stream.new(name)
#	       s.check_text_encoding()
#		l << line_input_stream.new(s)
#	_endcatch
#	_if l _is _unset _then _return 1 _endif
#	
#	_protect
#		# set up dynamic environment
#		_dynamic !abort! << abortn
#
#		# Don't pass down compiler stream if we are compiling since it
#		# won't be available when loading the compiled code.
#		_dynamic !compiler_input! << _if compiled_output _isnt _unset
#					     _then >> _unset
#					     _else >> l
#					     _endif
#		_dynamic !compiler_file! << system.canonicalise(name)
#	       _dynamic !patch_module! << _unset
#	       _dynamic !source_file! << _if source_file_name _isnt _unset
#					  _then >> system.canonicalise(source_file_name)
#					  _endif.default(!compiler_file!)
#
#		_dynamic (!current_module!, !module_file!) << _self.module_and_path(!source_file!)
#		
#		_dynamic !current_package!
#
#		
#		_self.write_message(!output!, :loading, name)
#
#		_dynamic !global_auto_declare?!	# so updates dynamic not global
#		_catch taga	# abort load
#
#		       _handling load_file_stop _with 
#				_proc (cond) 
#					_import taga, stopped?
#					cond.report_contents_on (!output!) 
#					newline_char.write_on (!output!)
#					stopped? << _true
#					_throw taga 
#				_endproc 
#
#		       _loop
#			       _catch tagc	# continue load
#				      _self.write_message(!output!, :loading_line, l.line_number)
#				      _if _not l.more_to_get? _then _leave _endif
#				      _if _not _self.load_chunk(l, compiled_output)
#				      _then !abort!()
#				      _endif
#			       _endcatch
#		       _endloop
#		_endcatch
#	_protection
#		l.close()
#	_endprotect
#	_self.report_end_loading_and_check_symbol_table( name )	
#	>> errors.value, stopped?
#_endmethod
#$
